//
//  SFTPService.swift
//  SSHTerminal
//
//  Phase 5: SFTP File Operations
//

import Foundation
import Citadel
import NIO

enum SFTPError: Error {
    case notConnected
    case operationFailed(String)
    case fileNotFound
    case permissionDenied
    case invalidPath
}

struct RemoteFileInfo: Identifiable, Equatable {
    let id = UUID()
    let name: String
    let path: String
    let size: Int64
    let permissions: String
    let isDirectory: Bool
    let modifiedDate: Date
    let owner: String
    let group: String
    
    var displaySize: String {
        ByteCountFormatter.string(fromByteCount: size, countStyle: .file)
    }
    
    var icon: String {
        isDirectory ? "folder.fill" : "doc.fill"
    }
}

@MainActor
class SFTPService: ObservableObject {
    @Published var currentPath: String = "/"
    @Published var files: [RemoteFileInfo] = []
    @Published var isLoading = false
    @Published var errorMessage: String?
    
    private var sftpClient: SFTPClient?
    private weak var sshClient: SSHClient?
    
    func connect(using sshClient: SSHClient) async throws {
        self.sshClient = sshClient
        do {
            self.sftpClient = try await sshClient.openSFTP()
            try await listDirectory(currentPath)
        } catch {
            throw SFTPError.operationFailed("SFTP connection failed: \(error.localizedDescription)")
        }
    }
    
    func disconnect() async {
        sftpClient = nil
        sshClient = nil
        files = []
        currentPath = "/"
    }
    
    // MARK: - Directory Operations
    
    func listDirectory(_ path: String) async throws {
        guard let sftp = sftpClient else {
            throw SFTPError.notConnected
        }
        
        isLoading = true
        errorMessage = nil
        
        do {
            let entries = try await sftp.listDirectory(atPath: path)
            
            var fileList: [RemoteFileInfo] = []
            for entry in entries {
                // Skip . and ..
                if entry.filename == "." || entry.filename == ".." {
                    continue
                }
                
                let fullPath = path.hasSuffix("/") ? path + entry.filename : path + "/" + entry.filename
                
                let fileInfo = RemoteFileInfo(
                    name: entry.filename,
                    path: fullPath,
                    size: Int64(entry.attributes.size ?? 0),
                    permissions: formatPermissions(entry.attributes.permissions ?? 0),
                    isDirectory: entry.attributes.permissions?.isDirectory ?? false,
                    modifiedDate: Date(timeIntervalSince1970: TimeInterval(entry.attributes.lastModified ?? 0)),
                    owner: String(entry.attributes.userId ?? 0),
                    group: String(entry.attributes.groupId ?? 0)
                )
                
                fileList.append(fileInfo)
            }
            
            // Sort: directories first, then alphabetically
            files = fileList.sorted { f1, f2 in
                if f1.isDirectory != f2.isDirectory {
                    return f1.isDirectory
                }
                return f1.name.localizedCaseInsensitiveCompare(f2.name) == .orderedAscending
            }
            
            currentPath = path
            isLoading = false
        } catch {
            isLoading = false
            errorMessage = error.localizedDescription
            throw SFTPError.operationFailed("List directory failed: \(error.localizedDescription)")
        }
    }
    
    func navigateToParentDirectory() async throws {
        let parentPath = (currentPath as NSString).deletingLastPathComponent
        try await listDirectory(parentPath.isEmpty ? "/" : parentPath)
    }
    
    func createDirectory(name: String) async throws {
        guard let sftp = sftpClient else {
            throw SFTPError.notConnected
        }
        
        let newPath = currentPath.hasSuffix("/") ? currentPath + name : currentPath + "/" + name
        
        do {
            try await sftp.createDirectory(atPath: newPath)
            try await listDirectory(currentPath)
        } catch {
            throw SFTPError.operationFailed("Create directory failed: \(error.localizedDescription)")
        }
    }
    
    // MARK: - File Operations
    
    func uploadFile(localURL: URL, remoteName: String? = nil) async throws {
        guard let sftp = sftpClient else {
            throw SFTPError.notConnected
        }
        
        let fileName = remoteName ?? localURL.lastPathComponent
        let remotePath = currentPath.hasSuffix("/") ? currentPath + fileName : currentPath + "/" + fileName
        
        do {
            let fileData = try Data(contentsOf: localURL)
            let buffer = ByteBuffer(data: fileData)
            
            try await sftp.writeFile(atPath: remotePath, contents: buffer)
            try await listDirectory(currentPath)
        } catch {
            throw SFTPError.operationFailed("Upload failed: \(error.localizedDescription)")
        }
    }
    
    func downloadFile(_ fileInfo: RemoteFileInfo, toURL localURL: URL) async throws {
        guard let sftp = sftpClient else {
            throw SFTPError.notConnected
        }
        
        do {
            let buffer = try await sftp.readFile(atPath: fileInfo.path)
            let data = Data(buffer: buffer)
            try data.write(to: localURL)
        } catch {
            throw SFTPError.operationFailed("Download failed: \(error.localizedDescription)")
        }
    }
    
    func deleteFile(_ fileInfo: RemoteFileInfo) async throws {
        guard let sftp = sftpClient else {
            throw SFTPError.notConnected
        }
        
        do {
            if fileInfo.isDirectory {
                try await sftp.removeDirectory(atPath: fileInfo.path)
            } else {
                try await sftp.removeFile(atPath: fileInfo.path)
            }
            try await listDirectory(currentPath)
        } catch {
            throw SFTPError.operationFailed("Delete failed: \(error.localizedDescription)")
        }
    }
    
    func renameFile(_ fileInfo: RemoteFileInfo, newName: String) async throws {
        guard let sftp = sftpClient else {
            throw SFTPError.notConnected
        }
        
        let newPath = (fileInfo.path as NSString).deletingLastPathComponent + "/" + newName
        
        do {
            try await sftp.rename(atPath: fileInfo.path, toPath: newPath)
            try await listDirectory(currentPath)
        } catch {
            throw SFTPError.operationFailed("Rename failed: \(error.localizedDescription)")
        }
    }
    
    func changePermissions(_ fileInfo: RemoteFileInfo, permissions: UInt16) async throws {
        guard let sftp = sftpClient else {
            throw SFTPError.notConnected
        }
        
        do {
            var attrs = SFTPFileAttributes()
            // TODO: Fix FilePermissions type
            // attrs.permissions = FilePermissions(rawValue: permissions)
            try await sftp.setAttributes(attrs, atPath: fileInfo.path)
            try await listDirectory(currentPath)
        } catch {
            throw SFTPError.operationFailed("Change permissions failed: \(error.localizedDescription)")
        }
    }
    
    // MARK: - Helpers
    
    private func formatPermissions(_ permissions: UInt16) -> String {
        let types = (permissions & 0o040000) != 0 ? "d" : "-"
        let owner = formatPermissionTriple(permissions >> 6)
        let group = formatPermissionTriple(permissions >> 3)
        let other = formatPermissionTriple(permissions)
        
        return types + owner + group + other
    }
    
    private func formatPermissionTriple(_ value: UInt16) -> String {
        let r = (value & 0b100) != 0 ? "r" : "-"
        let w = (value & 0b010) != 0 ? "w" : "-"
        let x = (value & 0b001) != 0 ? "x" : "-"
        return r + w + x
    }
}

// MARK: - FilePermissions Helper (Removed extension)
